<!DOCTYPE html>
<html>
<head>
  <title>Extreme Writing for Cool Teens B)</title>
</head>
<body>

  <label for="sessionLengthInput" >Session length (minutes):</label>
  <input id="sessionLengthInput" type="number" data-default=10>

  <label for="gracePeriodInput">Idle grace period (seconds):</label>
  <input id="gracePeriodInput" type="number" data-default=3>

  <br>

  <button id="activate"></button>

  <br>

  <span id="sessionTimer" data-seconds="0">00:00</span>
  <span id="graceTimer" data-seconds="0">00:00</span>

  <br>

  <textarea id="mainInput"></textarea>

  <br>

  <p id="debugArea"></p>

</body>
<script type="text/javascript">

  const ONE_SECOND = 1000

  window.onload = () => setState("READY")

  activate.addEventListener("click", () => {
    switch(activate.dataset.state) {
    case "READY":
      setSessionTimer(60*parseInt(sessionLengthInput.value))
      setState("UNPAUSED")
      break
    case "UNPAUSED":
      setState("PAUSED")
      break
    case "PAUSED":
      setState("UNPAUSED")
      break
    case "DONE":
      sessionTimer.classList.remove("done")
      setSessionTimer(60*parseInt(sessionLengthInput.value))
      setState("UNPAUSED")
      break
    default:
      console.error(`unknown state '${activate.dataset.state}'`)
      return
    }
  })

  function setState(state) {
    activate.dataset.state = state
    switch(state) {
    case "READY":
      debug('ready!')
      activate.innerText = "Start"
      mainInput.placeholder = "waiting for session to start..."
      mainInput.disabled = true
      sessionLengthInput.disabled = false
      gracePeriodInput.disabled = false

      sessionLengthInput.value = sessionLengthInput.dataset.default
      gracePeriodInput.value = gracePeriodInput.dataset.default
      break
    case "UNPAUSED":
      activate.innerText = "Pause"
      mainInput.placeholder = "Write!"
      mainInput.disabled = false
      sessionLengthInput.disabled = true
      gracePeriodInput.disabled = true
      mainInput.focus()

      resetGraceInterval({start: true})
      resetSessionInterval({start: true})
      break
    case "PAUSED":
      activate.innerText = "Unpause"
      mainInput.disabled = true
      sessionLengthInput.disabled = true
      gracePeriodInput.disabled = false

      resetGraceInterval({start: false})
      resetSessionInterval({start: false})
      break
    case "DONE":
      activate.innerText = "Restart"
      sessionTimer.classList.add("done")
      mainInput.disabled = false
      sessionLengthInput.disabled = false
      gracePeriodInput.disabled = false

      resetGraceInterval({start: false})
      resetSessionInterval({start: false})
      break
    default: console.error(`unknown state '${activate.dataset.state}'`)
    }
  }

  let sessionInterval
  function resetSessionInterval({start, hard}) {
    clearInterval(sessionInterval)
    if (start) {
      sessionInterval = setInterval(() => {
        seconds = parseInt(sessionTimer.dataset.seconds)
        seconds -= 1
        setSessionTimer(seconds)
        if (seconds <= 0) {
          setState("DONE")
        }
      }, ONE_SECOND)
    }
  }

  let graceInterval
  function resetGraceInterval({start}) {
    clearInterval(graceInterval)
    if (start) {
      graceInterval = setInterval(() => {
        seconds = parseInt(graceTimer.dataset.seconds)
        seconds -= 1
        if (seconds >= 0) {
          setGraceTimer(seconds)
        } else {
          graceTimer.classList.add("danger")
          setTimeout(() => graceTimer.classList.remove("danger"), 1/4*ONE_SECOND)
          mainInput.value = dropLastWord(mainInput.value)
        }
      }, ONE_SECOND)
    }

    setGraceTimer(gracePeriodInput.value)
  }

  function noticeTyping(e) {
    debug(JSON.stringify(e))
    if (e.data && /\S+/.exec(e.data)) {
      setGraceTimer(gracePeriodInput.value)
    }
  }
  mainInput.addEventListener("input", noticeTyping)
  mainInput.addEventListener("paste", noticeTyping)

  sessionLengthInput.addEventListener('blur', () => {
    // remove floats, use default
    sessionLengthInput.value = parseInt(sessionLengthInput.value) || sessionLengthInput.dataset.default
  })
  gracePeriodInput.addEventListener('blur', () => {
    // remove floats, use default
    gracePeriodInput.value = parseInt(gracePeriodInput.value) || gracePeriodInput.dataset.default
  })

  //
  // helpers
  //

  function debug(text) {
    if (text) {
      debugArea.innerText = text
      mainInput.style.height = "10vh"
    } else {
      debugArea.innerText = ""
      mainInput.style.height = "80vh" //@TODO sync with default somehow
    }
  }

  function setSessionTimer(seconds) {
    sessionTimer.dataset.seconds = seconds
    sessionTimer.innerText = formatSeconds(seconds)
  }

  function setGraceTimer(seconds) {
    graceTimer.dataset.seconds = seconds
    graceTimer.innerText = formatSeconds(seconds)
  }

  function divmod(y, x) {
    return {
      div: Math.floor(y/x),
      mod: y % x,
    }
  }

  // formats an integer number of seconds as a "mm:ss" string
  function formatSeconds(seconds) {
    const { div: mm, mod: ss } = divmod(seconds, 60)
    return `${leftpad(mm, 2, "0")}:${leftpad(ss, 2, "0")}`
  }

  function dropLastWord(text) {
    if (!/\S/.exec(text)) {
      // no words yet
      return text
    }
    // const result = /\s*\S+\s*$/.exec(text)
    const result = /\S+\s*$/.exec(text)
    if (result) {
      return text.slice(0, result.index)
    } else {
      console.error(`couldn't remove last word of '${text}'`)
      return text
    }
  }

  function leftpad (str, len, ch) {
    str = String(str);

    var i = -1;

    if (!ch && ch !== 0) ch = ' ';

    len = len - str.length;

    while (++i < len) {
      str = ch + str;
    }

    return str;
  }

</script>
<style type="text/css">

  body {
    background: lightgray;
  }

  #mainInput {
    /*margin: auto;*/
    width: 80vw;
    height: 80vh;
  }

  #graceTimer {
    font-size: 1em;
  }
  #graceTimer.danger {
    color: red;
  }

  #sessionTimer {
    font-size: 1.5em;
  }
  #sessionTimer.done {
    font-size: 2em;
    color: green;
  }

</style>
</html>
