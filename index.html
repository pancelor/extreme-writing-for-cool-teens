<!DOCTYPE html>
<html>
<head>
  <title>Extreme Writing for Cool Teens B)</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABl0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC4yMfEgaZUAAAUNSURBVHhe7du9zRw3FIXhLUKBOzAUOVMfUi2GXIADwz04cyJAZbgVO3MPa0xGvj7Yg4v52SF5gieYuSS/y7kn2EB6PJ/PXX7/659nvA/nUSVfVqim4jqcR5V8WaGaiutwHlXyZYVqKq7DeVTJly31R2McnCfJly11aIyD8yT5sqUOjXFwniRfttShMQ7Ok/73Qh0S8+C8u4eN2hTz4Ly7h43aFPPgvLuHjdoU8+C8u4eN2hTz4Ly7h43aFPPgvLuHjdoU8+C8u4eN2hTz4Lwz8MUlAItLABaXACwuAVhcArC4BGBxCcDi3h6A718+vaT27PHzTx9fUntmlgCA2jOzBADUnpklAKD2zOzyAKghV6gzX1FDrlBnziQBMNSZM0kADHXmTBIAQ505k7cH4Pnno8M6qSG11J5X1BktdYeZJADijJa6w0wSAHFGS91hJgmAOKOl7jCT2/8I5EDUmiOpnmeWAIDqeWYJAKieZ5YAgOp5ZpcHgNQQ7kT1PJMEwFA9zyQBMFTPM0kADNXzTN4eAFJDeKePP3x4Sd1hJAmAoYbeUncYSQJgqKG31B1GkgAYaugtdYeRTB+Ax+PRUWteUUNvqTuMJAEw1NBb6g4jSQAMNfSWusNIEgBDDb2l7jCS2wWA1FDeSfU4sgSgSPU4sgSgSPU4sgSgSPU4suECcPU/ECHV48gSgCLV48gSgCLV48gSgCLV48huFwD10V9hIEjtqVA9ziQBMFSPM0kADNXjTBIAQ/U4k+EDQCoEr6geVpIAiB5WkgCIHlaSAIgeVvL2AKghtjgwtaZC9bCyBGBxCcDiEoDFTReA6nrV00oSANHTShIA0dNKEgDR00p2B+DXr3901JpX1FBa1YGS2696WkkCIHpaSQIgelpJAiB6Wkk5ABz485dvHdbVGS0OxHEDJbee/bz7P3/ye6o1R0oA0E8CYHDAbJh1dUaLA3HcQMmtZz8JgMEBs2HW1RktDsRxAyW3nv0kAEUc+OPvTx2udwOp4nnk1rN+dQA48Oe/P/ZQV2fskQCgngAUJQD7cMAJQBHPI7ee9QSgiAMnrncDuBv2T4/fPneqdeLA3ffcKwEw2D+5Abs6JQA3w/7JDdjVKQG4GfZPbsCuTrcLQPUCextWQ3gn9ue+h6tX8XuS2lORABjsz30PV6/i9yS1pyIBMNif+x6uXsXvSWpPRQJgsD/3PVy9it+T1J6K8o/A6gWr60fj7ufqztEDpwRgJ3c/V3cSgJtz93N1JwG4OXc/V3feHoDqBdz6vXU6ev3eelX1PLfe1SkBOLheVT3PrXd1SgAOrldVz3PrXZ0SgIPrVdXz3HpXp/KPwCrXkKuTW+/q5NbvrZNb7+pUXU8JgFm/t05uvatTdT0lAGb93jq59a5O1fWUAJj1e+vk1rs6VdfT6QE4m/sArk5uvauTW+/qZ0sAwK13dXLrXf1sCQC49a5Obr2rny0BALfe1cmtd/WzPZ7Pnlp0JHdhV7/a3frZi/PuHjZq05HcB3X1q92tn7047+5hozYdyX1QV7/a3frZi/PuHjZq05HcB3X1q92tn7047+5hozadabYPfHecd/ewUZvOlABci/PuHjZq05kSgGtx3t3DRm06UwJwLc67e1DUITEOzpPky5Y6NMbBeZJ82VKHxjg4T5IvW+rQGAfnSfJlhfqjcR3Oo0q+rFBNxXU4jyr5skI1FdfhPKrkywrVVFyH86h5Pv4DHMhmNQAgxycAAAAASUVORK5CYII=">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>

  <div id="settingsContainer">
    <button id="activate"></button>

    <div>
      <label for="sessionLengthInput" >Session length (minutes):</label>
      <input id="sessionLengthInput" type="number" data-default=10>
    </div>

    <div>
      <label for="gracePeriodInput">Idle grace period (seconds):</label>
      <input id="gracePeriodInput" type="number" data-default=3>
    </div>
  </div>

  <div id="stateContainer">
    <div>
      <span id="sessionTimer" data-seconds="0">00:00</span>
      <span id="graceTimer" data-seconds="0">00:00</span>
    </div>
  </div>

  <div id="inputContainer">
    <div>
      <textarea id="mainInput"></textarea>
    </div>

    <div>
      <label for="wordCount">words:</label>
      <span id="wordCount">0</span>
    </div>
  </div>

  <p id="debugArea" class="disabled"></p>

</body>
<script type="text/javascript">

  const ONE_SECOND = 1000

  window.onload = () => {
    setupLocalStorage()
    setState("READY")
  }

  activate.addEventListener("click", () => {
    switch(activate.dataset.state) {
    case "READY":
      setSessionTimer(60*parseInt(sessionLengthInput.value))
      setState("UNPAUSED")
      break
    case "UNPAUSED":
      setState("PAUSED")
      break
    case "PAUSED":
      setState("UNPAUSED")
      break
    case "DONE":
      sessionTimer.classList.remove("done")
      setSessionTimer(60*parseInt(sessionLengthInput.value))
      setState("UNPAUSED")
      break
    default:
      console.error(`unknown state '${activate.dataset.state}'`)
      return
    }
  })

  function setState(state) {
    activate.dataset.state = state
    switch(state) {
    case "READY":
      activate.innerText = "Start"
      mainInput.placeholder = "waiting for session to start..."
      mainInput.disabled = true
      sessionLengthInput.disabled = false
      gracePeriodInput.disabled = false

      sessionLengthInput.value = LS.get("sessionLength") || sessionLengthInput.dataset.default
      gracePeriodInput.value = LS.get("gracePeriod") || gracePeriodInput.dataset.default
      break
    case "UNPAUSED":
      activate.innerText = "Pause"
      mainInput.placeholder = "Write!"
      mainInput.disabled = false
      sessionLengthInput.disabled = true
      gracePeriodInput.disabled = true
      mainInput.focus()

      resetGraceInterval({start: true})
      resetSessionInterval({start: true})
      break
    case "PAUSED":
      activate.innerText = "Unpause"
      mainInput.disabled = true
      sessionLengthInput.disabled = false
      gracePeriodInput.disabled = false

      resetGraceInterval({start: false})
      resetSessionInterval({start: false})
      break
    case "DONE":
      activate.innerText = "Restart"
      sessionTimer.classList.add("done")
      mainInput.disabled = false
      sessionLengthInput.disabled = false
      gracePeriodInput.disabled = false

      resetGraceInterval({start: false})
      resetSessionInterval({start: false})
      break
    default:
      console.error(`unknown state '${activate.dataset.state}'`)
      activate.dataset.state = "READY"
      break
    }
  }
  function getState(state) {
    return activate.dataset.state
  }

  let sessionInterval
  function resetSessionInterval({start, hard}) {
    clearInterval(sessionInterval)
    if (start) {
      sessionInterval = setInterval(() => {
        seconds = parseInt(sessionTimer.dataset.seconds)
        seconds -= 1
        setSessionTimer(seconds)
        if (seconds <= 0) {
          setState("DONE")
        }
      }, ONE_SECOND)
    }
  }

  let graceInterval
  function resetGraceInterval({start}) {
    clearInterval(graceInterval)
    if (start) {
      graceInterval = setInterval(() => {
        seconds = parseInt(graceTimer.dataset.seconds)
        seconds -= 1
        if (seconds >= 0) {
          setGraceTimer(seconds)
        } else {
          graceTimer.classList.add("danger")
          setTimeout(() => graceTimer.classList.remove("danger"), 1/4*ONE_SECOND)
          mainInput.value = dropLastWord(mainInput.value)
          noticeWordCount()
        }
      }, ONE_SECOND)
    }

    setGraceTimer(gracePeriodInput.value)
  }

  function noticeWordCount() {
    wordCount.innerText = countWords(mainInput.value)
  }

  function noticeTyping(e) {
    if (e.data && /^\S$/.exec(e.data)) {
      setGraceTimer(gracePeriodInput.value)
    }
    noticeWordCount()
  }

  // mainInput.addEventListener("keyup", noticeTyping) // for android
  mainInput.addEventListener("input", noticeTyping)

  sessionLengthInput.addEventListener('blur', () => {
    // remove floats, use default, store
    const v = parseInt(sessionLengthInput.value) || sessionLengthInput.dataset.default
    if (LS.get("sessionLength") !== v) {
      // made changes
      sessionLengthInput.value = v
      LS.set("sessionLength", v)
      if (getState() === "PAUSED") {
        setSessionTimer(60*parseInt(sessionLengthInput.value))
        setState("READY")
      }
    }
  })
  gracePeriodInput.addEventListener('blur', () => {
    // remove floats, use default, store
    const v = parseInt(gracePeriodInput.value) || gracePeriodInput.dataset.default
    gracePeriodInput.value = v
    LS.set("gracePeriod", v)
  })

  //
  // helpers
  //

  function assert(b, msg=null) {
    if (!b) {
      msg = (msg === null) ? "assert error" : msg
      throw new Error(msg)
    }
  }

  function debug(text) {
    let toset
    if (text) {
      debugArea.innerText = text
    } else {
      debugArea.innerText = ""
    }
    if (debugArea.classList.contains('enabled')) {
      mainInput.style.height = toset
    }
  }

  function setSessionTimer(seconds) {
    sessionTimer.dataset.seconds = seconds
    sessionTimer.innerText = formatSeconds(seconds)
  }

  function setGraceTimer(seconds) {
    graceTimer.dataset.seconds = seconds
    graceTimer.innerText = formatSeconds(seconds)
  }

  function divmod(y, x) {
    return {
      div: Math.floor(y/x),
      mod: y % x,
    }
  }

  // formats an integer number of seconds as a "mm:ss" string
  function formatSeconds(seconds) {
    const { div: mm, mod: ss } = divmod(seconds, 60)
    return `${leftpad(mm, 2, "0")}:${leftpad(ss, 2, "0")}`
  }

  function defaultOpt(opt, def) {
    return (opt === undefined) ? def : opt
  }

  function dropLastWord(text) {
    if (!/\S/.exec(text)) {
      // no words yet
      return text
    }
    // const result = /\s*\S+\s*$/.exec(text)
    const result = /\S+\s*$/.exec(text)
    if (result) {
      return text.slice(0, result.index)
    } else {
      console.error(`couldn't remove last word of '${text}'`)
      return text
    }
  }

  function countWords(text) {
    return (text || "").split(/\s+/).filter(x=>x).length
  }

  function leftpad (str, len, ch) {
    str = String(str);

    var i = -1;

    if (!ch && ch !== 0) ch = ' ';

    len = len - str.length;

    while (++i < len) {
      str = ch + str;
    }

    return str;
  }

  //
  // local storage
  //

  // LS is an interface built on top of the browser's localStorage.
  // If you work with window.localStorage directly, you need lots of
  // boilerplate code to avoid unwanted errors, e.g.:
  //   try {
  //      if (!!window.localStorage) {
  //        localStorage["foo"]=JSON.stringify([1,2,3]);
  //        var bar = JSON.parse(localStorage["bar"]);
  //      }
  //    } catch (ex) { }
  // With this interface, this becomes:
  //   LS.set("foo",[1,2,3])
  //   var bar = LS.get("bar")
  // Think of LS as a dictionary that persists itself to
  // the browser's localStorage, if available.

  var LS = {
    _cache: {}, // an in-memory copy of the browser's localStorage
    _shouldSync: false, // whether the real window.localStorage is available
  };

  LS.populateCache = function populateCache() {
    for (var key of Object.keys(window.localStorage)) {
      var val = window.localStorage[key];
      try {
        LS._cache[key] = JSON.parse(val);
      } catch (err) {
        console.warn(`Error parsing window.localStorage: [${key}]=${val}`);
      }
    }
  }

  LS.set = function set(key, val) {
    LS._cache[key] = val;
    if (LS._shouldSync) window.localStorage[key] = JSON.stringify(val);
  }

  LS.get = function get(key) {
    return LS._cache[key];
  }

  LS.del = function del(key) {
    delete LS._cache[keys];
    if (LS._shouldSync) delete window.localStorage[key];
  }

  LS.clear = function clear() {
    LS._cache = {};
    if (LS._shouldSync) window.localStorage.clear();
  }

  // call once during window.onload
  function setupLocalStorage() {
    if (isLocalStorageAvailable()) {
      LS._shouldSync = true
      LS.populateCache()
    }
  }

  function isLocalStorageAvailable() {
    try {
      // accessing localStorage at all will throw an error if it's not available
      var x = window.localStorage;
      return true;
    } catch (e) {
      return false;
    }
  }

</script>
<style type="text/css">

  body {
    background: #353535;
    display: flex;
    flex-direction: column;
  }
  span {
    color: #eee;
  }

  textarea {
    background: #3f3f3f;
    color: #eee;
    caret-color: #aaa;
  }
  textarea::placeholder {
    color: #aaa;
  }

  label {
    color: #c7c7c7;
  }

  #mainInput {
    width: 80%;
    height: 80%;
    min-height: 10vh;
    padding: 5px;
  }

  #graceTimer {
    font-size: 1em;
  }
  #graceTimer.danger {
    color: red;
  }

  #sessionTimer {
    font-size: 1.5em;
  }
  #sessionTimer.done {
    font-size: 2em;
    color: green;
  }

  #debugArea.disabled {
    display: none;
  }

  #settingsContainer {
    display: flex;
    flex-direction: row;
    justify-content: flex-start;
  }
  #settingsContainer>* {
    padding: 10px
  }

  #stateContainer>* {
    padding: 10px
  }

</style>
</html>
